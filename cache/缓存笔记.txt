读多写少 适合缓存
大体上分成
    1.本地缓存
    2.分布式缓存 redis memcache

Beego API
：单个操作
：批量操作
：针对数字的自增自减

Go-cache
:单个操作
:针对数字的加减操作

如何处理过期时间的策略
1.每个key开一个goroutine盯着
缺点：key多了goroutine也就多了，
同时这些goroutine大多时候被阻塞住了

2.定期轮询，然后删除
创建cache时候，同时创建一个goroutine ,这个goroutine会检查
每一个检查key过期的时间，并且在过期后执行删除
要点：
   要控制检查间隔：过短影响用户，资源消耗过大
   要控制住遍历的资源开销：如果全部Key遍历一遍，那么可能消耗时间长，因为遍历时候要加锁所以会影响业务
   可以控制遍历时常
   可以遍历数量
轮训+Get 两种结合 防止一直没人get


3.永不过期，访问时候删除


Redis的过期处理：
get 时候检查是否过期
遍历key找出过期的删除

与sql.DB空闲连接关闭对比
Get懒惰关闭 只用了这个
只有在Get它时候才会关闭


优化手段 用ekit的延时队列

evict 回调与关闭

部分情况下，缓存中间件可以考虑提供CDC接口 change data capture 接口
类似与redis的subscribe
在本地缓存实现中，这种个接口主要就是缓存过期被删除的回调
核心 ：把变更前后的上下文都暴露出去

控制本地缓存内存
  淘汰算法
  两种策略：
     控制键值对数量：比如说只允许十万个键值对
     控制整体内存：需要计算每个对象的大小，然后累加
使用装饰器模式


利用你的API来Redis:





