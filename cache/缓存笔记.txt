读多写少 适合缓存
大体上分成
    1.本地缓存
    2.分布式缓存 redis memcache

Beego API
：单个操作
：批量操作
：针对数字的自增自减

Go-cache
:单个操作
:针对数字的加减操作

如何处理过期时间的策略
1.每个key开一个goroutine盯着
缺点：key多了goroutine也就多了，
同时这些goroutine大多时候被阻塞住了

2.定期轮询，然后删除
创建cache时候，同时创建一个goroutine ,这个goroutine会检查
每一个检查key过期的时间，并且在过期后执行删除
要点：
   要控制检查间隔：过短影响用户，资源消耗过大
   要控制住遍历的资源开销：如果全部Key遍历一遍，那么可能消耗时间长，因为遍历时候要加锁所以会影响业务
   可以控制遍历时常
   可以遍历数量
轮训+Get 两种结合 防止一直没人get


3.永不过期，访问时候删除


Redis的过期处理：
get 时候检查是否过期
遍历key找出过期的删除

与sql.DB空闲连接关闭对比
Get懒惰关闭 只用了这个
只有在Get它时候才会关闭


优化手段 用ekit的延时队列

evict 回调与关闭

部分情况下，缓存中间件可以考虑提供CDC接口 change data capture 接口
类似与redis的subscribe
在本地缓存实现中，这种个接口主要就是缓存过期被删除的回调
核心 ：把变更前后的上下文都暴露出去

控制本地缓存内存
  淘汰算法
  两种策略：
     控制键值对数量：比如说只允许十万个键值对
     控制整体内存：需要计算每个对象的大小，然后累加
使用装饰器模式


利用你的API来Redis:
组合API
多个动作组合在一起，作为一个API来提供
这种组合API要注意安全： 线程安全。在本地实现加锁就可以，在Redis里要用lua脚本

缓存的面试要点：
缓存过期时间怎么控制？一共三种
定期删除过期缓存有什么注意？注意控制CPU开销，防止定期删除占用太多资源
为什么无法做到缓存一过期就删除？借助于缓存队列可以勉强做到。 不是很现实，
本地缓存如何避免占用内存？控制内存使用量，可以控制内存总量，可以控制键值对总数。
如何提供缓存的内存利用率？

缓存模式
常用的：
Cache Aside：
    什么都不用就是。
    把cache当作一个普通的业务源
    Cache和DB都依赖于业务逻辑
    采用singleflight
    不管怎么操作，redis或者mysql这种没有真正达成一致的方案，都是多大程度下容忍
    唯一可能是缓存中间件要实现分布式事物
    缺点：缓存和cache不一致

Read Through：
    业务代码只需要从Cache中读取数据，cache会在缓存不命中时候读取数据
    写数据的时候，业务代码需要自己写DB和ceach






