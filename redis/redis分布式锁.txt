什么是分布式锁：
    简单来说就是在分布式环境下不同实例之间抢一把锁
    和普通的锁比起来，也就是抢锁的从goroutine变成了实例
    难：和网络有关

用redis来实现：
实现分布式锁的起点，就是利用setnx命令，setnx key1=value1 如果这个值存在就返回一个失败的响应
    只要能保证可以排他地设置键值对就可以实现分布式锁

    1.为啥加过期时间:
        防止拿到锁的实例崩掉没人释放
    2.过期时间很难控制要怎么办？

    3.为什么用uuid作为值：
        场景：实例1抢到锁，实例2等待锁
             实例1过期后，实例2抢到锁
             实例1完成业务后把锁释放，然后实例3抢到了
    释放锁时候，先看是不是自己的锁然后在释放 在这个时候组合在一起确保do这个时候没人修改锁

   过期时间设置多长？
    设置短了，业务没完成，锁就过期了
    设置长了，实例崩了，其他实例也长时间拿不到锁

    手动续约：
    续约：在考虑锁没过期时候在延长时间
    1.过期时间不会设置很长，自动帮我们设置好
    2.实例崩了就没续约了
    难点：判断这个锁是不是你的锁
    业务方怎么用

    自动续约：
    要考虑：多久续约，续约多长
    如何处理超时：怎么处理

    分布式锁：加锁重试
        偶发性失败，如果超时了，那么直接加锁
        检查key对应的值是不是我们刚才加时请求的值
        key1不存在
        key1=value1
        重试加锁，key1=value2 这个是别人的锁

        怎么重试
        隔多久重试

redis主从切换
    预期：一切顺利  如果复制--成ok 释放锁
    发生问题 还没复制 那么redis2 上你没有锁

    Readlock 多个主节点 五个都加上锁，如果是多数三个以上那么认为加锁成功


    面试题目：
    分布式锁怎么实现
    过期设置怎么设置
    怎么延长过期时间
    加锁失败有什么原因
    怎么优化分布式锁的性能

    总结：使用分布式锁


   缓存一致性根源性：
   并发更新： 用分部署锁解决  cache改为1 -- chache--2 DB--2 cahche--1
   部分失败：更新缓存或者DB其中一个失败了

    write-back ：
        本地缓存不可能
        redis缓存未命中，不回查DB 在调用者的调度不存在
        未命中，从DB往回加载的同时 有个新数据来修改
        缓解：回查 SetNX命令
    refresh-ahead:
        天然能接受短期不一致

     可能方案:
        结合哈希一致性负载均衡算法+singleflight,
        如果是使用本地缓存

        分布式锁的方案 强一致性，极端写少的场景
      核心都是控制住全局只有一个goroutine取更新一个特定key的数据
      解决并发更新，但是还有缓存失败


    问题：
    缓存模式能不能解决缓存一致性？
    数据不一致怎么办？
    怎么解决缓存不一致的问题？

