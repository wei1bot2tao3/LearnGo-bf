channel 与goroutine泄漏
什么时候goroutine泄漏
使用不当：
1.只送不收 ：分有没有缓存
2.只收不送
3.读写nil都会导致goroutine泄漏
一直没办法发，收（忘记初始化）
初始化，但是close了那么读只能读到零值，写panic
goroutine泄漏都是因为goroutine被阻塞后一直没有人唤醒它

业务层面上的监视趋势：一直增长

内存逃逸与 channel
内存分配：
  分配到栈上：不需要GC
  分配到堆上：需要考虑GC
用channel发送到指针，必然逃逸

channel底层实现
从设计者的角度
要不要设计缓冲
要阻塞和唤醒
发数据的唤醒收数据的
收数据的唤醒发数据
要维持住goroutine的等待队列，并且是收和发两个队列

实现细节：
buf ring buffer结构作为缓存：因为channel是固定的大小的
recvq 底层都是waitq 是一个双向链表，简单来说就是队列
sendq

发送时候缓存没满，或者有接收者直接就发，否则直接放到 recvq

chansend
 1.如果是空的nil的channel直接阻塞，无法唤醒
 c.recvq.dequeue
 2.没有缓冲或者缓冲区为空的时候，直接给接收者
 3. 没有接收者，放到缓冲里
 4.没有缓冲或者满了就自己阻塞住自己
 	：KeepAlive(ep)
 	保证被阻塞的的不会被垃圾回收掉
 5.被唤醒，做清理工作

chanrecv
1.先检查是不是niu
2.有发送者的时候：
   如果channel缓冲为0，那么直接取走发送着的数据
   有缓冲时候，取走队首的数据，把发送者的数据放到队尾
3.没有发送者，那就进缓冲拿
4.没有发送者，没有缓冲就阻塞 进队列
5.被唤醒，拿到数据



会引起goroutine阻塞的就可能引起goroutine泄露

学习要点：
带不带缓冲
谁在发
谁在收
谁在关
关了吗？
